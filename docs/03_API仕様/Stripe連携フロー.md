# Stripe Checkout 連携フロー\n\nこのドキュメントは、TimekeeperにおけるStripe Checkoutを利用した決済処理の連携フローを記述します。\nライセンス購入フロー (P01) とデイパス購入フロー (P05) の両方で同様の連携フローを想定しています。\n\n## 登場人物\n\n*   **クライアント**: Androidアプリ\n*   **バックエンド**: FastAPIサーバー\n*   **Stripe**: 決済プラットフォーム\n\n## 連携シーケンス\n\n```mermaid\nsequenceDiagram\n    participant Client as クライアント (Android)\n    participant Backend as バックエンド (FastAPI)\n    participant Stripe as Stripe API/Checkout\n\n    Client->>Backend: 1. 決済セッション開始リクエスト (device_id, 商品種別など)\n    activate Backend\n    Backend->>Stripe: 2. 決済セッション作成 (商品情報、成功URL、キャンセルURL)\n    activate Stripe\n    Stripe-->>Backend: 3. 決済セッションID、決済ページURL\n    deactivate Stripe\n    Backend-->>Client: 4. 決済ページURL\n    deactivate Backend\n\n    Client->>Stripe: 5. 決済ページ表示 (WebView内でURLを開く)\n    activate Stripe\n    Note over Client, Stripe: ユーザーがStripe Checkoutページで決済情報を入力し、実行\n    Stripe-->>Client: 6. 決済完了後、指定の成功URLにリダイレクト (purchase_token等を付与)\n    deactivate Stripe\n\n    Client->>Backend: 7. 決済確認リクエスト (device_id, purchase_token)\n    activate Backend\n    Backend->>Stripe: 8. purchase_token (または決済セッションID) を検証\n    activate Stripe\n    Stripe-->>Backend: 9. 検証結果 (成功/失敗)\n    deactivate Stripe\n    alt 検証成功\n        Backend->>Backend: 10. Firestoreのデバイス情報を更新 (ライセンス情報 or デイパス情報)\n        Backend-->>Client: 11. 成功レスポンス (購入情報など)\n    else 検証失敗 or Firestore更新失敗\n        Backend-->>Client: 12. 失敗レスポンス\n    end\n    deactivate Backend\n```\n\n## 各ステップ詳細\n\n1.  **決済セッション開始リクエスト (クライアント → バックエンド)**\n    *   クライアントは、ライセンス購入またはデイパス購入の意思をバックエンドに伝えます。\n    *   リクエストには `device_id` と、どちらの購入フローかを示す情報（例: `product_type: \"license\"` or `product_type: \"daypass\"`）を含めます。\n    *   デイパス購入の場合、現在の `unlock_count` も送信し、バックエンドで価格を決定できるようにすることも考えられます。\n\n2.  **決済セッション作成 (バックエンド → Stripe)**\n    *   バックエンドは、Stripe APIを使用して決済セッションを作成します。\n    *   この際、以下の情報をStripeに渡します:\n        *   **商品情報**: 価格、通貨、商品名など。デイパスの場合は `unlock_count` に基づいて価格を動的に設定します。\n        *   **成功URL**: 決済成功後にStripe Checkoutがリダイレクトするクライアント側のURL（ディープリンクやカスタムURLスキームを利用）。このURLには、後続の検証で利用する一時的なトークン (`purchase_token` など) をクエリパラメータとしてStripeが付与するように設定します。\n        *   **キャンセルURL**: ユーザーが決済をキャンセルした場合にリダイレクトするクライアント側のURL。\n\n3.  **決済セッションID、決済ページURL (Stripe → バックエンド)**\n    *   Stripeは、作成された決済セッションのIDと、ユーザーをリダイレクトさせるための決済ページURLをバックエンドに返します。\n\n4.  **決済ページURL (バックエンド → クライアント)**\n    *   バックエンドは、Stripeから受け取った決済ページURLをクライアントに返します。\n\n5.  **決済ページ表示 (クライアント → Stripe)**\n    *   クライアントは、受け取った決済ページURLをWebViewなどで表示し、ユーザーに決済手続きを促します。\n\n6.  **決済完了後リダイレクト (Stripe → クライアント)**\n    *   ユーザーがStripe Checkoutページで決済を正常に完了すると、Stripeはステップ2で設定された成功URLにリダイレクトします。\n    *   この際、URLのクエリパラメータとして `purchase_token`（またはStripeの決済セッションIDなど、バックエンドでの検証に使える識別子）が付与されている想定です。\n    *   クライアントはこの `purchase_token` を取得します。\n\n7.  **決済確認リクエスト (クライアント → バックエンド)**\n    *   クライアントは、取得した `purchase_token` と `device_id` をバックエンドの決済確認API（例: `/license/confirm`, `/unlock/daypass`）に送信します。\n\n8.  **purchase\_token 検証 (バックエンド → Stripe)**\n    *   バックエンドは、受け取った `purchase_token` をStripe APIに問い合わせて、その有効性（実際に決済が完了しているかなど）を検証します。\n\n9.  **検証結果 (Stripe → バックエンド)**\n    *   Stripeは検証結果をバックエンドに返します。\n\n10. **Firestoreのデバイス情報更新 (バックエンド)**\n    *   Stripeでの決済検証が成功した場合、バックエンドはFirestoreの `devices` コレクション内の該当ドキュメントを更新します。\n        *   ライセンス購入の場合: ライセンス購入済みフラグ、購入日時などを記録。\n        *   デイパス購入の場合: `unlock_count` をインクリメント、`last_unlock_date` を更新。\n\n11. **成功レスポンス (バックエンド → クライアント)**\n    *   Firestoreへの更新も成功した場合、バックエンドはクライアントに成功レスポンスを返します。\n    *   レスポンスには、更新後のライセンス状態や `unlock_count` などの情報を含めることができます。\n\n12. **失敗レスポンス (バックエンド → クライアント)**\n    *   Stripeでの決済検証に失敗した場合、またはFirestoreへの更新に失敗した場合は、バックエンドはクライアントに適切なエラーレスポンスを返します。\n\n## 注意事項・補足\n\n*   **`purchase_token` の実装**: `purchase_token` は、バックエンドがStripeの決済セッションIDと紐付けて一時的に生成・管理するトークンとするか、Stripeの決済セッションIDそのものを利用するかなどを具体的に決定する必要があります。セキュリティを考慮し、一度きりの使用や有効期限を設けることが推奨されます。\n*   **成功URL/キャンセルURL**: クライアントアプリ内でWebViewからの遷移を受け取るために、ディープリンクやカスタムURLスキームの実装が必要です。\n*   **エラーハンドリング**: 各ステップでのエラー（ネットワークエラー、Stripe APIエラー、Firestoreエラーなど）を適切にハンドリングし、ユーザーに分かりやすいフィードバックを提供する必要があります。特に、決済は成功したがバックエンド処理に失敗した場合の補償フロー（例: P06のエラー案内）は重要です。\n*   **Webhook**: より堅牢なシステムにするためには、Stripe Webhookを利用して、決済完了などのイベントを非同期的にバックエンドで受信し、処理することも検討できます。これにより、クライアントからの確認リクエストが何らかの理由で到達しなかった場合でも、決済状態を正しく更新できます。 